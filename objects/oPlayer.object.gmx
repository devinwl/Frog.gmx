<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>oParEntity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Inherit oParEntity variables
event_inherited();

// Player swapping for 1P mode
activePlayer = true;
playerNum = 0;

// Constants
KEY_RIGHT          = 0;
KEY_UP             = 1;
KEY_LEFT           = 2;
KEY_DOWN           = 3;
KEY_JUMP           = 4;

KEY_ATTACK         = 5;
KEY_SPECIAL        = 6;
KEY_PICKUP_PLAYER  = 7;
KEY_THROW_PLAYER   = 8;

// Default controls
KEY_LIST[KEY_RIGHT] = vk_right;
KEY_LIST[KEY_UP]    = vk_up;
KEY_LIST[KEY_LEFT]  = vk_left;
KEY_LIST[KEY_DOWN]  = vk_down;
KEY_LIST[KEY_JUMP] = ord('Z');
KEY_LIST[KEY_ATTACK] = ord('X');
KEY_LIST[KEY_SPECIAL] = ord('C');
KEY_LIST[KEY_PICKUP_PLAYER] = ord('V');
KEY_LIST[KEY_THROW_PLAYER] = vk_down;

// Modify Entity Attach points
attachPointDeltaX = -6;
attachPointDeltaY = -4;

// Movement ///////////////////////////////////////////////////////////////////

// Multiplier
m = 1.0;

groundAccel = 1.0  * m;
groundFric  = 1.9  * m;
airAccel    = 0.2 * m;
airFric     =  0.05 * m;
vxMax       = 2.0  * m;
vyMax       = 7.0 * m;
jumpHeight  = 6.0  * m;
gravNorm    = 0.33  * m;
gravSlide   = 0.05 * m;
airThrownFric = 0.05 * m;

sticking = false;
clingTime   = 20 * m;

climbing = false;

playerCanMove = true;
playerCanBeHurt = true;

playerStunTimerMax = 60;
playerStunTimer = playerStunTimerMax;

playerInFlight = false;

// Misc ///////////////////////////////////////////////////////////////////////

// Relative collision checks
cLeft  = place_meeting(x - 1, y, oParSolid);
cRight = place_meeting(x + 1, y, oParSolid);

// Common calculation
sqrt2 = sqrt(2);

// State information
PLAYER_STATE_IDLE = 1;
PLAYER_STATE_RUNNING = 2;
PLAYER_STATE_JUMP_BEGIN = 3;
PLAYER_STATE_JUMP_MID = 4;
PLAYER_STATE_JUMP_FALLING = 5;
PLAYER_STATE_CLINGING = 6;
PLAYER_STATE_STUNNED = 7;
PLAYER_STATE_FLYING = 8;
PLAYER_STATE_ATTACHED = 9;
PLAYER_STATE_HURT = 10;
PLAYER_STATE_JUMP_INIT = 11;

playerState = PLAYER_STATE_IDLE;

// Animation stuff
SPR_PLAYER_IDLE = sprPlayer1;
SPR_IDLE_SPEED = 0.10;

SPR_PLAYER_RUN = sprPlayer1Run;
SPR_RUNNING_SPEED = 0.2;

SPR_PLAYER_JUMP = sprPlayer1Jump;
SPR_JUMPING_SPEED = 0;

SPR_PLAYER_CLINGING = sprPlayer1Cling;
SPR_CLINGING_SPEED = 0;

SPR_PLAYER_HURT = sprPlayer1Hurt;
SPR_PLAYER_HURT_SPEED = 0;

SPR_PLAYER_STUNNED = sprPlayer1Stunned;
SPR_PLAYER_STUNNED_SPEED = 0;

SPR_PLAYER_FLYING = sprPlayer1Flying;
SPR_PLAYER_FLYING_SPEED = 0;

xScale = 1;
yScale = 1;

// Melee attack stuff, move later
attackTimer = 0;
attackMaxFrames = sprite_get_number(sprPlayer1MeleeAttack) / 0.3;

PLAYER_STATE_ATTACKING = 99;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(sticking) {
    sticking = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Inherit oParEntity variables
event_inherited();

// Relative collision checks
cLeft  = place_meeting(x - 1, y, oParSolid);
cRight = place_meeting(x + 1, y, oParSolid);

// Get facing direction
facing = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Input //////////////////////////////////////////////////////////////////////

var kLeft, kRight, kUp, kDown, kJump, kJumpRelease, tempAccel, tempFric;
var kRoll;

// Only return keys as true if the player can move
// Otherwise just apply gravity as normal
kLeft        = keyboard_check(KEY_LIST[KEY_LEFT]) &amp;&amp; scr_PlayerCanMove(self.id);
kRight       = keyboard_check(KEY_LIST[KEY_RIGHT]) &amp;&amp; scr_PlayerCanMove(self.id);
kUp          = keyboard_check(KEY_LIST[KEY_UP]) &amp;&amp; scr_PlayerCanMove(self.id);
kDown        = keyboard_check(KEY_LIST[KEY_DOWN]) &amp;&amp; scr_PlayerCanMove(self.id);

kJump        = keyboard_check_pressed(KEY_LIST[KEY_JUMP]) &amp;&amp; scr_PlayerCanMove(self.id);
kJumpRelease = keyboard_check_released(KEY_LIST[KEY_JUMP]) &amp;&amp; scr_PlayerCanMove(self.id);

kGrabPlayer  = keyboard_check_pressed(KEY_LIST[KEY_PICKUP_PLAYER]) &amp;&amp; scr_PlayerCanMove(self.id);

// Gravity and such

// Apply the correct form of acceleration and friction
if (onGround) {
    tempAccel = groundAccel;
    tempFric  = groundFric;
} else {
    tempAccel = airAccel;
    tempFric  = airFric;
}

// Reset wall cling
if ((!cRight &amp;&amp; !cLeft) || onGround) {
    canStick = true;
    sticking = false;
}   

// Cling to wall
if (((kRight &amp;&amp; cRight) || (kLeft &amp;&amp; cLeft)) &amp;&amp; canStick &amp;&amp; !onGround &amp;&amp; !entityAttached) {
    alarm[0] = clingTime;
    sticking = true; 
    canStick = false;       
}

// Left 
if (kLeft &amp;&amp; !kRight &amp;&amp; !sticking &amp;&amp; !climbing) {
    // Apply acceleration left
    if (vx &gt; 0)
        vx = Approach(vx, 0, tempFric);   
    vx = Approach(vx, -vxMax, tempAccel);
}

// Right 
if (kRight &amp;&amp; !kLeft &amp;&amp; !sticking &amp;&amp; !climbing) {
    // Apply acceleration right
    if (vx &lt; 0)
        vx = Approach(vx, 0, tempFric);   
    vx = Approach(vx, vxMax, tempAccel);
}

// Friction
if (!kRight &amp;&amp; !kLeft)
    vx = Approach(vx, 0, tempFric); 
 
// Wall jump
if (kJump &amp;&amp; cLeft &amp;&amp; !onGround &amp;&amp; !entityAttached) {
    if (kLeft) {
        vy = -jumpHeight * 1.1;
        vx =  jumpHeight * .75;
    } else {
        vy = -jumpHeight * 1.1;
        vx =  vxMax;
    }  
}

if (kJump &amp;&amp; cRight &amp;&amp; !onGround &amp;&amp; !entityAttached) {
    if (kRight) {
        vy = -jumpHeight * 1.1;
        vx = -jumpHeight * .75;
    } else {
        vy = -jumpHeight * 1.1;
        vx = -vxMax;
    }  
}
 
// Jump 
if (kJump) { 
    if (onGround) {
        vy = -jumpHeight;
    }
    // Variable jumping
} else if (kJumpRelease) { 
    if (vy &lt; 0)
        vy *= 0.25;
}

// Throw/Release held player
if(kGrabPlayer &amp;&amp; entityAttached) {

    if(kUp) {
        throwVx = (3.5*entityFacing);
        throwVy =  -8;
    } else if(kDown) {
        throwVx = 0;
        throwVy = -2;
    } else {
        throwVx = (6*entityFacing);
        throwVy = -4;
    }
    
    scr_ThrowAttachedPlayer(self, entityAttached, throwVx, throwVy);
}

// Grab Player
// Todo: don't pickup stunned players
if(kGrabPlayer &amp;&amp; (scr_GetEntityInFrontOfPlayer(self.id, oPlayer) != noone) &amp;&amp; !playerInFlight) {
    iPlayer = scr_GetEntityInFrontOfPlayer(self.id, oPlayer);
    if(!scr_IsPlayerBusy(iPlayer)) {
        scr_PickupPlayer(self, iPlayer);
    }
}

if(keyboard_check(ord('B'))) {
    scr_KnockbackPlayer(self, 4, 2);
}

// Handle Stun timers

// Once the stun timer has expired, the player can move and is no longer invincible
if(onGround &amp;&amp; playerStunTimer == playerStunTimerMax) {
    playerCanMove = true;
    playerCanBeHurt = true;
}

// Increment stun timer, stop the player's movement while they are stunned
if(onGround &amp;&amp; playerStunTimer &lt;= playerStunTimerMax) {
    playerStunTimer++;
    scr_StopPlayer(self);
}

// Knockback Player from walls after being flung
if( (cRight || cLeft) &amp;&amp; playerInFlight ) {
    playerInFlight = false;
    scr_KnockbackPlayer(self, 1, 2);
}

// Players landing normally still get stunned
if(onGround &amp;&amp; playerInFlight) {
    playerInFlight = false;
    scr_StunPlayer(self);
}

// Ladders
if(kUp &amp;&amp; place_meeting(x,y,oParLadder)) {
    var ladder = instance_place(x,y,oLadder);
    x = ladder.x;
    climbing = true;
    vy = 0;
    vx = 0;
}

if(climbing) {
    if(kUp) {
        vy = -2;
    }
    else if(kDown) {
        vy = 2;
    }
    else {
        vy = 0;
    }
}

if(onGround || !place_meeting(x,y-1, oParLadder)) {
    climbing = false;
}

// Handle gravity
if (!onGround &amp;&amp; !attachedTo &amp;&amp; !climbing) {
    if (( (cLeft &amp;&amp; kLeft) || (cRight &amp;&amp; kRight)) &amp;&amp; vy &gt;= 0 &amp;&amp; sticking) {
        // Wall slide
        vy = Approach(vy, vyMax, gravSlide);
    } else {
        // Fall normally
        vy = Approach(vy, vyMax, gravNorm);
    }
}

if(kDown &amp;&amp; place_meeting(x,y+1, oParJumpThru)) { passThru = true; y++ } else passThru = false;


/*
// Springs
if(place_meeting(x,y+vy,oSpringboard)) {
    var sB = instance_place(x,y+vy,oSpringboard);
    sB.image_speed = 0.30;
    vy = -9;
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>playerState = scr_GetPlayerState(self.id);

scr_DrawPlayer(self);

//draw_text(x-8,y-12,string(cLeft));
//draw_text(x+8,y-12,string(cRight));
//draw_text(x,y-16,string(canStick));
//draw_text(x,y+2,string(sticking));

//draw_text(x,y-16,string(vy));

//draw_rectangle(x-2,y-6,x+12,y+12,true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>12,12</point>
  </PhysicsShapePoints>
</object>
